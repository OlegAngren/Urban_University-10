import time  # Импортируем модуль time для измерения времени выполнения
from multiprocessing import Pool  # Импортируем Pool для многопроцессной обработки

def read_info(name):
    """
    Функция для считывания данных из файла.
    :param name: Имя файла.
    """
    all_data = []  # Локальный список для хранения данных из файла
    with open(name, 'r', encoding='utf-8') as file:  # Открываем файл для чтения
        while True:
            line = file.readline()  # Читаем файл построчно
            if not line:  # Если строка пустая, завершаем чтение
                break
            all_data.append(line.strip())  # Добавляем строку в список, удаляя лишние пробелы и символы
    # Возвращать all_data не требуется по условию задачи, но список можно использовать для дальнейшей обработки

def create_test_files():
    """
    Создание тестовых файлов с числами в указанных диапазонах.
    Каждый файл будет содержать числа от start до end включительно.
    """
    ranges = [
        (1, 9999999),  # Первый файл: числа от 1 до 9,999,999
        (10000000, 19999999),  # Второй файл: числа от 10,000,000 до 19,999,999
        (20000000, 29999999),  # Третий файл: числа от 20,000,000 до 29,999,999
        (30000000, 39999999)  # Четвертый файл: числа от 30,000,000 до 39,999,999
    ]
    for i, (start, end) in enumerate(ranges, 1):  # Перебираем диапазоны и создаем файлы
        with open(f'file_{i}.txt', 'w', encoding='utf-8') as file:  # Открываем файл для записи
            for number in range(start, end + 1):  # Записываем числа от start до end
                file.write(f"{number}\n")  # Каждое число записываем на новой строке

# Создаем тестовые файлы (выполнить один раз)
# Если файлы уже существуют, этот шаг можно пропустить
create_test_files()

# Список файлов для обработки
# Генерируем имена файлов: file_1.txt, file_2.txt, file_3.txt, file_4.txt
filenames = [f'file_{i}.txt' for i in range(1, 5)]

# Линейное выполнение: считываем файлы по очереди
start_time = time.time()  # Засекаем время начала выполнения
for filename in filenames:  # Перебираем каждый файл в списке
    read_info(filename)  # Вызываем функцию read_info для каждого файла
linear_time = time.time() - start_time  # Вычисляем время выполнения
print(f"Линейное выполнение: {linear_time} секунд")  # Выводим время выполнения

# Многопроцессное выполнение: считываем файлы параллельно
if __name__ == '__main__':  # Обязательно для многопроцессного подхода
    start_time = time.time()  # Засекаем время начала выполнения
    with Pool(processes=4) as pool:  # Создаем пул из 4 процессов (по одному на каждый файл)
        pool.map(read_info, filenames)  # Распараллеливаем выполнение функции read_info
    multiprocessing_time = time.time() - start_time  # Вычисляем время выполнения
    print(f"Многопроцессное выполнение: {multiprocessing_time} секунд")  # Выводим время выполнения

    """ Пояснения к коду
1. Функция read_info(name)
    Назначение: Считывает данные из файла построчно и сохраняет их в локальный список.

    Параметры:

        name: Имя файла, который нужно прочитать.

    Логика:

        Открывает файл в режиме чтения ('r').

        Читает файл построчно с помощью readline().

        Если строка пустая, цикл завершается.

        Каждая строка добавляется в список all_data.

2. Функция create_test_files()
    Назначение: Создает тестовые файлы с числами в указанных диапазонах.

    Логика:

    Использует список диапазонов ranges, где каждый элемент — это кортеж (start, end).

    Для каждого диапазона создается файл с именем file_<номер>.txt.

    В файл записываются числа от start до end, каждое на новой строке.

3. Линейное выполнение
    Назначение: Считывает файлы последовательно, один за другим.

    Логика:

    Засекаем время начала выполнения.

    Перебираем каждый файл в списке filenames и вызываем функцию read_info.

    Вычисляем общее время выполнения и выводим его.

4. Многопроцессное выполнение
    Назначение: Считывает файлы параллельно, используя несколько процессов.

    Логика:

    Используем Pool из модуля multiprocessing для создания пула процессов.

    Метод map применяет функцию read_info к каждому элементу списка filenames параллельно.

    Засекаем время выполнения и выводим его.

5. Конструкция if __name__ == '__main__'
    Назначение: Обеспечивает корректную работу многопроцессного подхода на всех платформах.

    Почему важно: На Windows и macOS без этой конструкции может возникнуть ошибка из-за особенностей запуска процессов."""